
<!DOCTYPE HTML>
<html lang="zh" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>第十三章 • 条件分支 · 学C语言写Lisp</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-disqus/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-anchor-navigation-ex-toc/style/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-collapse/collapse.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="website-1533951536666.css">
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    
        <link rel="shortcut icon" href="./assets/logo.png" type="image/x-icon">
    
    
    

    
    <link rel="next" href="14.Strings.html" />
    
    
    <link rel="prev" href="12.Functions.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            <div class="book-logo">   
                
                <img src="./assets/logo.png"/>
                
            </div>
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="輸入並搜尋" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        
        <li class="chapter 
              "
            data-level="1.1" 
            data-path="./">

            
                <a href="./">
            
                    
                    第零零章 • 关于
            
                </a>
            

            
        </li>
    
        
        <li class="chapter 
              "
            data-level="1.2" 
            data-path="01.Introduction.html">

            
                <a href="01.Introduction.html">
            
                    
                    第零一章 • 介绍
            
                </a>
            

            
        </li>
    
        
        <li class="chapter 
              "
            data-level="1.3" 
            data-path="02.Installation.html">

            
                <a href="02.Installation.html">
            
                    
                    第零二章 • 安装
            
                </a>
            

            
        </li>
    
        
        <li class="chapter 
              "
            data-level="1.4" 
            data-path="03.Basics.html">

            
                <a href="03.Basics.html">
            
                    
                    第零三章 • 基础
            
                </a>
            

            
        </li>
    
        
        <li class="chapter 
              "
            data-level="1.5" 
            data-path="04.Interactive.html">

            
                <a href="04.Interactive.html">
            
                    
                    第零四章 • 交互
            
                </a>
            

            
        </li>
    
        
        <li class="chapter 
              "
            data-level="1.6" 
            data-path="05.Languages.html">

            
                <a href="05.Languages.html">
            
                    
                    第零五章 • 编程语言
            
                </a>
            

            
        </li>
    
        
        <li class="chapter 
              "
            data-level="1.7" 
            data-path="06.Parsing.html">

            
                <a href="06.Parsing.html">
            
                    
                    第零六章 • 语法分析
            
                </a>
            

            
        </li>
    
        
        <li class="chapter 
              "
            data-level="1.8" 
            data-path="07.Evaluation.html">

            
                <a href="07.Evaluation.html">
            
                    
                    第零七章 • 计算
            
                </a>
            

            
        </li>
    
        
        <li class="chapter 
              "
            data-level="1.9" 
            data-path="08.Error-Handling.html">

            
                <a href="08.Error-Handling.html">
            
                    
                    第零八章 • 错误处理
            
                </a>
            

            
        </li>
    
        
        <li class="chapter 
              "
            data-level="1.10" 
            data-path="09.S-Expressions.html">

            
                <a href="09.S-Expressions.html">
            
                    
                    第零九章 • S-表达式
            
                </a>
            

            
        </li>
    
        
        <li class="chapter 
              "
            data-level="1.11" 
            data-path="10.Q-Expressions.html">

            
                <a href="10.Q-Expressions.html">
            
                    
                    第零十章 • Q-表达式
            
                </a>
            

            
        </li>
    
        
        <li class="chapter 
              "
            data-level="1.12" 
            data-path="11.Variables.html">

            
                <a href="11.Variables.html">
            
                    
                    第十一章 • 变量
            
                </a>
            

            
        </li>
    
        
        <li class="chapter 
              "
            data-level="1.13" 
            data-path="12.Functions.html">

            
                <a href="12.Functions.html">
            
                    
                    第十二章 • 函数
            
                </a>
            

            
        </li>
    
        
        <li class="chapter 
            active  selected  "
            data-level="1.14" 
            data-path="13.Conditionals.html">

            
                <a href="13.Conditionals.html">
            
                    
                    第十三章 • 条件分支
            
                </a>
            

            
        </li>
    
        
        <li class="chapter 
              "
            data-level="1.15" 
            data-path="14.Strings.html">

            
                <a href="14.Strings.html">
            
                    
                    第十四章 • 字符串
            
                </a>
            

            
        </li>
    
        
        <li class="chapter 
              "
            data-level="1.16" 
            data-path="15.Standard-Library.html">

            
                <a href="15.Standard-Library.html">
            
                    
                    第十五章 • 标准库
            
                </a>
            

            
        </li>
    
        
        <li class="chapter 
              "
            data-level="1.17" 
            data-path="16.Bonus-Projects.html">

            
                <a href="16.Bonus-Projects.html">
            
                    
                    第十六章 • 彩蛋
            
                </a>
            

            
        </li>
    
        
        <li class="chapter 
              "
            data-level="1.18" 
            data-path="Appendix.html">

            
                <a href="Appendix.html">
            
                    
                    附录
            
                </a>
            

            
        </li>
    
        
        <li class="chapter 
              "
            data-level="1.19" 
            >

            
                <a target="_blank" href="https://github.com/NoahDragon/BuildYourOwnLispCn/raw/master/source.tar.gzasserts/source.tar.gz">
            
                    
                    源代码
            
                </a>
            

            
        </li>
    
        
        <li class="chapter 
              "
            data-level="1.20" 
            >

            
                <a target="_blank" href="http://buildyourownlisp.com/contents">
            
                    
                    英文原版在线阅读
            
                </a>
            

            
        </li>
    
        
        <li class="chapter 
              "
            data-level="1.21" 
            >

            
                <a target="_blank" href="https://github.com/NoahDragon/BuildYourOwnLispCn">
            
                    
                    Github
            
                </a>
            

            
        </li>
    

    
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >第十三章 • 条件分支</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <div id="anchor-navigation-ex-navbar"><i class="fa fa-anchor"></i><ul><li><span class="title-icon "></span><a href="#chapter-13-conditionals"><b>1. </b>Chapter 13 Conditionals</a></li><ul><li><span class="title-icon "></span><a href="#doing-it-yourself"><b>1.1. </b>Doing it yourself</a></li><li><span class="title-icon "></span><a href="#ordering"><b>1.2. </b>Ordering</a></li><li><span class="title-icon "></span><a href="#equality"><b>1.3. </b>Equality</a></li><li><span class="title-icon "></span><a href="#if-function"><b>1.4. </b>If Function</a></li><li><span class="title-icon "></span><a href="#recursive-functions"><b>1.5. </b>Recursive Functions</a></li><li><span class="title-icon "></span><a href="#bonus-marks"><b>1.6. </b>Bonus Marks</a></li><li><span class="title-icon "></span><a href="#reference"><b>1.7. </b>Reference</a></li></ul></ul></div><a href="#chapter-13-conditionals" id="anchorNavigationExGoTop"><i class="fa fa-arrow-up"></i></a><h1 id="chapter-13-conditionals"><a name="chapter-13-conditionals" class="anchor-navigation-ex-anchor" href="#chapter-13-conditionals"><i class="fa fa-link" aria-hidden="true"></i></a>1. Chapter 13 Conditionals</h1>
<h2 id="doing-it-yourself"><a name="doing-it-yourself" class="anchor-navigation-ex-anchor" href="#doing-it-yourself"><i class="fa fa-link" aria-hidden="true"></i></a>1.1. Doing it yourself</h2>
<p>We&apos;ve come quite far now. Your knowledge of C should be good enough for you to stand on your own feet a little more. If you&apos;re feeling confident, this chapter is a perfect opportunity to stretch your wings out and attempt something on your own. It is a fairly short chapter and essentially consists of adding a couple of new builtin functions to deal with comparison and ordering.</p>
<p>If you&apos;re feeling positive, go ahead and try to implement comparison and ordering into your language now. Define some new builtin functions for greater than, less than, equal to, and all the other comparison operators we use in C. Try to define an <code>if</code> function that tests for some condition and then either evaluate some code, or some other code, depending on the result. Once you&apos;ve finished come back and compare your work to mine. Observe the differences and decide which parts you prefer.</p>
<p>If you still feel uncertain don&apos;t worry. Follow along and I&apos;ll explain my approach.</p>
<h2 id="ordering"><a name="ordering" class="anchor-navigation-ex-anchor" href="#ordering"><i class="fa fa-link" aria-hidden="true"></i></a>1.2. Ordering</h2>
<p>For simplicity&apos;s sake I&apos;m going to re-use our number data type to represent the result of comparisons. I&apos;ll make a rule similar to C, to say that any number that isn&apos;t <code>0</code> evaluates to true in an <code>if</code> statement, while <code>0</code> always evaluates to false.</p>
<p>Therefore our ordering functions are a little like a simplified version of our arithmetic functions. They&apos;ll only work on numbers, and we only want them to work on two arguments.</p>
<p>If these error conditions are met the maths is simple. We want to return a number <code>lval</code> either <code>0</code> or <code>1</code> depending on the equality comparison between the two input <code>lval</code>. We can use C&apos;s comparison operators to do this. Like our arithmetic functions we&apos;ll make use of a single function to do all of the comparisons.</p>
<p>First we check the error conditions, then we compare the numbers in each of the arguments to get some result. Finally we return this result as a number value.</p>
<pre><code class="lang-c"><span class="hljs-function">lval* <span class="hljs-title">builtin_gt</span><span class="hljs-params">(lenv* e, lval* a)</span> </span>{
  <span class="hljs-keyword">return</span> builtin_ord(e, a, <span class="hljs-string">&quot;&gt;&quot;</span>);
}
</code></pre>
<pre><code class="lang-c"><span class="hljs-function">lval* <span class="hljs-title">builtin_lt</span><span class="hljs-params">(lenv* e, lval* a)</span> </span>{
  <span class="hljs-keyword">return</span> builtin_ord(e, a, <span class="hljs-string">&quot;&lt;&quot;</span>);
}
</code></pre>
<pre><code class="lang-c"><span class="hljs-function">lval* <span class="hljs-title">builtin_ge</span><span class="hljs-params">(lenv* e, lval* a)</span> </span>{
  <span class="hljs-keyword">return</span> builtin_ord(e, a, <span class="hljs-string">&quot;&gt;=&quot;</span>);
}
</code></pre>
<pre><code class="lang-c"><span class="hljs-function">lval* <span class="hljs-title">builtin_le</span><span class="hljs-params">(lenv* e, lval* a)</span> </span>{
  <span class="hljs-keyword">return</span> builtin_ord(e, a, <span class="hljs-string">&quot;&lt;=&quot;</span>);
}
</code></pre>
<pre><code class="lang-c"><span class="hljs-function">lval* <span class="hljs-title">builtin_ord</span><span class="hljs-params">(lenv* e, lval* a, <span class="hljs-keyword">char</span>* op)</span> </span>{
  LASSERT_NUM(op, a, <span class="hljs-number">2</span>);
  LASSERT_TYPE(op, a, <span class="hljs-number">0</span>, LVAL_NUM);
  LASSERT_TYPE(op, a, <span class="hljs-number">1</span>, LVAL_NUM);

  <span class="hljs-keyword">int</span> r;
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(op, <span class="hljs-string">&quot;&gt;&quot;</span>)  == <span class="hljs-number">0</span>) {
    r = (a-&gt;cell[<span class="hljs-number">0</span>]-&gt;num &gt;  a-&gt;cell[<span class="hljs-number">1</span>]-&gt;num);
  }
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(op, <span class="hljs-string">&quot;&lt;&quot;</span>)  == <span class="hljs-number">0</span>) {
    r = (a-&gt;cell[<span class="hljs-number">0</span>]-&gt;num &lt;  a-&gt;cell[<span class="hljs-number">1</span>]-&gt;num);
  }
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(op, <span class="hljs-string">&quot;&gt;=&quot;</span>) == <span class="hljs-number">0</span>) {
    r = (a-&gt;cell[<span class="hljs-number">0</span>]-&gt;num &gt;= a-&gt;cell[<span class="hljs-number">1</span>]-&gt;num);
  }
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(op, <span class="hljs-string">&quot;&lt;=&quot;</span>) == <span class="hljs-number">0</span>) {
    r = (a-&gt;cell[<span class="hljs-number">0</span>]-&gt;num &lt;= a-&gt;cell[<span class="hljs-number">1</span>]-&gt;num);
  }
  lval_del(a);
  <span class="hljs-keyword">return</span> lval_num(r);
}
</code></pre>
<h2 id="equality"><a name="equality" class="anchor-navigation-ex-anchor" href="#equality"><i class="fa fa-link" aria-hidden="true"></i></a>1.3. Equality</h2>
<p>Equality is going to be different to ordering because we want it to work on more than number types. It will be useful to see if an input is equal to an empty list, or to see if two functions passed in are the same. Therefore we need to define a function which can test for equality between two different types of <code>lval</code>.</p>
<p>This function essentially checks that all the fields which make up the data for a particular <code>lval</code> type are equal. If all the fields are equal, the whole thing is considered equal. Otherwise if there are any differences the whole thing is considered unequal.</p>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lval_eq</span><span class="hljs-params">(lval* x, lval* y)</span> </span>{

  <span class="hljs-comment">/* Different Types are always unequal */</span>
  <span class="hljs-keyword">if</span> (x-&gt;type != y-&gt;type) { <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; }

  <span class="hljs-comment">/* Compare Based upon type */</span>
  <span class="hljs-keyword">switch</span> (x-&gt;type) {
    <span class="hljs-comment">/* Compare Number Value */</span>
    <span class="hljs-keyword">case</span> LVAL_NUM: <span class="hljs-keyword">return</span> (x-&gt;num == y-&gt;num);

    <span class="hljs-comment">/* Compare String Values */</span>
    <span class="hljs-keyword">case</span> LVAL_ERR: <span class="hljs-keyword">return</span> (<span class="hljs-built_in">strcmp</span>(x-&gt;err, y-&gt;err) == <span class="hljs-number">0</span>);
    <span class="hljs-keyword">case</span> LVAL_SYM: <span class="hljs-keyword">return</span> (<span class="hljs-built_in">strcmp</span>(x-&gt;sym, y-&gt;sym) == <span class="hljs-number">0</span>);

    <span class="hljs-comment">/* If builtin compare, otherwise compare formals and body */</span>
    <span class="hljs-keyword">case</span> LVAL_FUN:
      <span class="hljs-keyword">if</span> (x-&gt;builtin || y-&gt;builtin) {
        <span class="hljs-keyword">return</span> x-&gt;builtin == y-&gt;builtin;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> lval_eq(x-&gt;formals, y-&gt;formals)
          &amp;&amp; lval_eq(x-&gt;body, y-&gt;body);
      }

    <span class="hljs-comment">/* If list compare every individual element */</span>
    <span class="hljs-keyword">case</span> LVAL_QEXPR:
    <span class="hljs-keyword">case</span> LVAL_SEXPR:
      <span class="hljs-keyword">if</span> (x-&gt;count != y-&gt;count) { <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; }
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; x-&gt;count; i++) {
        <span class="hljs-comment">/* If any element not equal then whole list not equal */</span>
        <span class="hljs-keyword">if</span> (!lval_eq(x-&gt;cell[i], y-&gt;cell[i])) { <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; }
      }
      <span class="hljs-comment">/* Otherwise lists must be equal */</span>
      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    <span class="hljs-keyword">break</span>;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>Using this function the new builtin function for equality comparison is very simple to add. We simply ensure two arguments are input, and that they are equal. We store the result of the comparison into a new <code>lval</code> and return it.</p>
<pre><code class="lang-c"><span class="hljs-function">lval* <span class="hljs-title">builtin_cmp</span><span class="hljs-params">(lenv* e, lval* a, <span class="hljs-keyword">char</span>* op)</span> </span>{
  LASSERT_NUM(op, a, <span class="hljs-number">2</span>);
  <span class="hljs-keyword">int</span> r;
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(op, <span class="hljs-string">&quot;==&quot;</span>) == <span class="hljs-number">0</span>) {
    r =  lval_eq(a-&gt;cell[<span class="hljs-number">0</span>], a-&gt;cell[<span class="hljs-number">1</span>]);
  }
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(op, <span class="hljs-string">&quot;!=&quot;</span>) == <span class="hljs-number">0</span>) {
    r = !lval_eq(a-&gt;cell[<span class="hljs-number">0</span>], a-&gt;cell[<span class="hljs-number">1</span>]);
  }
  lval_del(a);
  <span class="hljs-keyword">return</span> lval_num(r);
}

<span class="hljs-function">lval* <span class="hljs-title">builtin_eq</span><span class="hljs-params">(lenv* e, lval* a)</span> </span>{
  <span class="hljs-keyword">return</span> builtin_cmp(e, a, <span class="hljs-string">&quot;==&quot;</span>);
}

<span class="hljs-function">lval* <span class="hljs-title">builtin_ne</span><span class="hljs-params">(lenv* e, lval* a)</span> </span>{
  <span class="hljs-keyword">return</span> builtin_cmp(e, a, <span class="hljs-string">&quot;!=&quot;</span>);
}
</code></pre>
<h2 id="if-function"><a name="if-function" class="anchor-navigation-ex-anchor" href="#if-function"><i class="fa fa-link" aria-hidden="true"></i></a>1.4. If Function</h2>
<p>To make our comparison operators useful we&apos;ll need an <code>if</code> function. This function is a little like the ternary operation in C. Upon some condition being true it evaluates to one thing, and if the condition is false, it evaluates to another.</p>
<p>We can again make use of Q-Expressions to encode a computation. First we get the user to pass in the result of a comparison, then we get the user to pass in two Q-Expressions representing the code to be evaluated upon a condition being either true or false.</p>
<pre><code class="lang-c"><span class="hljs-function">lval* <span class="hljs-title">builtin_if</span><span class="hljs-params">(lenv* e, lval* a)</span> </span>{
  LASSERT_NUM(<span class="hljs-string">&quot;if&quot;</span>, a, <span class="hljs-number">3</span>);
  LASSERT_TYPE(<span class="hljs-string">&quot;if&quot;</span>, a, <span class="hljs-number">0</span>, LVAL_NUM);
  LASSERT_TYPE(<span class="hljs-string">&quot;if&quot;</span>, a, <span class="hljs-number">1</span>, LVAL_QEXPR);
  LASSERT_TYPE(<span class="hljs-string">&quot;if&quot;</span>, a, <span class="hljs-number">2</span>, LVAL_QEXPR);

  <span class="hljs-comment">/* Mark Both Expressions as evaluable */</span>
  lval* x;
  a-&gt;cell[<span class="hljs-number">1</span>]-&gt;type = LVAL_SEXPR;
  a-&gt;cell[<span class="hljs-number">2</span>]-&gt;type = LVAL_SEXPR;

  <span class="hljs-keyword">if</span> (a-&gt;cell[<span class="hljs-number">0</span>]-&gt;num) {
    <span class="hljs-comment">/* If condition is true evaluate first expression */</span>
    x = lval_eval(e, lval_pop(a, <span class="hljs-number">1</span>));
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">/* Otherwise evaluate second expression */</span>
    x = lval_eval(e, lval_pop(a, <span class="hljs-number">2</span>));
  }

  <span class="hljs-comment">/* Delete argument list and return */</span>
  lval_del(a);
  <span class="hljs-keyword">return</span> x;
}
</code></pre>
<p>All that remains is for us to register all of these new builtins and we are again ready to go.</p>
<pre><code class="lang-c"><span class="hljs-comment">/* Comparison Functions */</span>
lenv_add_builtin(e, <span class="hljs-string">&quot;if&quot;</span>, builtin_if);
lenv_add_builtin(e, <span class="hljs-string">&quot;==&quot;</span>, builtin_eq);
lenv_add_builtin(e, <span class="hljs-string">&quot;!=&quot;</span>, builtin_ne);
lenv_add_builtin(e, <span class="hljs-string">&quot;&gt;&quot;</span>,  builtin_gt);
lenv_add_builtin(e, <span class="hljs-string">&quot;&lt;&quot;</span>,  builtin_lt);
lenv_add_builtin(e, <span class="hljs-string">&quot;&gt;=&quot;</span>, builtin_ge);
lenv_add_builtin(e, <span class="hljs-string">&quot;&lt;=&quot;</span>, builtin_le);
</code></pre>
<p>Have a quick mess around to check that everything is working correctly.</p>
<pre><code>lispy&gt; &gt; 10 5
1
lispy&gt; &lt;= 88 5
0
lispy&gt; == 5 6
0
lispy&gt; == 5 {}
0
lispy&gt; == 1 1
1
lispy&gt; != {} 56
1
lispy&gt; == {1 2 3 {5 6}} {1   2  3   {5 6}}
1
lispy&gt; def {x y} 100 200
()
lispy&gt; if (== x y) {+ x y} {- x y}
-100
</code></pre><h2 id="recursive-functions"><a name="recursive-functions" class="anchor-navigation-ex-anchor" href="#recursive-functions"><i class="fa fa-link" aria-hidden="true"></i></a>1.5. Recursive Functions</h2>
<p>By introducing conditionals we&apos;ve actually made our language a lot more powerful. This is because they effectively let us implement recursive functions.</p>
<p>Recursive functions are those which call themselves. We&apos;ve used these already in C to perform reading in and evaluation of expressions. The reason we require conditionals for these is because they let us test for the situation where we wish to terminate the recursion.</p>
<p>For example we can use conditionals to implement a function <code>len</code> which tells us the number of items in a list. If we encounter the empty list we just return <code>0</code>. Otherwise we return the length of the <code>tail</code> of the input list, plus <code>1</code>. Think about why this works. It repeatedly uses the len function until it reaches the empty list. At this point it returns <code>0</code> and adds all the other partial results together.</p>
<pre><code>(fun {len l} {
  if (== l {})
    {0}
    {+ 1 (len (tail l))}
})
</code></pre><p>Just as in C, there is a pleasant symmetry to this sort of recursive function. First we do something for the empty list (the base case). Then if we get something bigger, we take off a chunk such as the head of the list, and do something to it, before combining it with the rest of the thing to which the function has been already applied.</p>
<p>Here is another function for reversing a list. As before it checks for the empty list, but this time it returns the empty list back. This makes sense. The reverse of the empty list is just the empty list. But if it gets something bigger than the empty list, it reverses the tail, and sticks this in front of the head.</p>
<pre><code>(fun {reverse l} {
  if (== l {})
    {{}}
    {join (reverse (tail l)) (head l)}
})
</code></pre><p>We&apos;re going to use this technique to build many functions. This is because it is going to be the primary way to achieve looping in our language.</p>
<h2 id="bonus-marks"><a name="bonus-marks" class="anchor-navigation-ex-anchor" href="#bonus-marks"><i class="fa fa-link" aria-hidden="true"></i></a>1.6. Bonus Marks</h2>
<ul>
<li>Create builtin logical operators or <code>||</code>, and <code>&amp;&amp;</code> and not <code>!</code> and add them to the language.</li>
<li>Define a recursive Lisp function that returns the <code>nth</code> item of that list.</li>
<li>Define a recursive Lisp function that returns <code>1</code> if an element is a member of a list, otherwise <code>0</code>.</li>
<li>Define a Lisp function that returns the last element of a list.</li>
<li>Define in Lisp logical operator functions such as <code>or</code>, <code>and</code> and <code>not</code>.</li>
<li>Add a specific boolean type to the language with the builtin variables <code>true</code> and <code>false</code>.</li>
</ul>
<h2 id="reference"><a name="reference" class="anchor-navigation-ex-anchor" href="#reference"><i class="fa fa-link" aria-hidden="true"></i></a>1.7. Reference</h2>
<p><details><summary>conditionals.c</summary><pre><code class="lang-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-string">&quot;mpc.h&quot;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _WIN32</span>

<span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> buffer[<span class="hljs-number">2048</span>];

<span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">readline</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* prompt)</span> </span>{
  <span class="hljs-built_in">fputs</span>(prompt, <span class="hljs-built_in">stdout</span>);
  fgets(buffer, <span class="hljs-number">2048</span>, <span class="hljs-built_in">stdin</span>);
  <span class="hljs-keyword">char</span>* cpy = <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">strlen</span>(buffer)+<span class="hljs-number">1</span>);
  <span class="hljs-built_in">strcpy</span>(cpy, buffer);
  cpy[<span class="hljs-built_in">strlen</span>(cpy)<span class="hljs-number">-1</span>] = <span class="hljs-string">&apos;\0&apos;</span>;
  <span class="hljs-keyword">return</span> cpy;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_history</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* unused)</span> </span>{}

<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;editline/readline.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;editline/history.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-comment">/* Forward Declarations */</span>

<span class="hljs-keyword">struct</span> lval;
<span class="hljs-keyword">struct</span> lenv;
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> lval lval;
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> lenv lenv;

<span class="hljs-comment">/* Lisp Value */</span>

<span class="hljs-keyword">enum</span> { LVAL_ERR, LVAL_NUM, LVAL_SYM, LVAL_FUN, LVAL_SEXPR, LVAL_QEXPR };

<span class="hljs-keyword">typedef</span> lval*(*lbuiltin)(lenv*, lval*);

<span class="hljs-keyword">struct</span> lval {
  <span class="hljs-keyword">int</span> type;

  <span class="hljs-comment">/* Basic */</span>
  <span class="hljs-keyword">long</span> num;
  <span class="hljs-keyword">char</span>* err;
  <span class="hljs-keyword">char</span>* sym;

  <span class="hljs-comment">/* Function */</span>
  lbuiltin builtin;
  lenv* env;
  lval* formals;
  lval* body;

  <span class="hljs-comment">/* Expression */</span>
  <span class="hljs-keyword">int</span> count;
  lval** cell;
};

<span class="hljs-function">lval* <span class="hljs-title">lval_num</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x)</span> </span>{
  lval* v = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(lval));
  v-&gt;type = LVAL_NUM;
  v-&gt;num = x;
  <span class="hljs-keyword">return</span> v;
}

<span class="hljs-function">lval* <span class="hljs-title">lval_err</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* fmt, ...)</span> </span>{
  lval* v = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(lval));
  v-&gt;type = LVAL_ERR;  
  va_list va;
  va_start(va, fmt);  
  v-&gt;err = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">512</span>);  
  vsnprintf(v-&gt;err, <span class="hljs-number">511</span>, fmt, va);  
  v-&gt;err = <span class="hljs-built_in">realloc</span>(v-&gt;err, <span class="hljs-built_in">strlen</span>(v-&gt;err)+<span class="hljs-number">1</span>);
  va_end(va);  
  <span class="hljs-keyword">return</span> v;
}

<span class="hljs-function">lval* <span class="hljs-title">lval_sym</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* s)</span> </span>{
  lval* v = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(lval));
  v-&gt;type = LVAL_SYM;
  v-&gt;sym = <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">strlen</span>(s) + <span class="hljs-number">1</span>);
  <span class="hljs-built_in">strcpy</span>(v-&gt;sym, s);
  <span class="hljs-keyword">return</span> v;
}

<span class="hljs-function">lval* <span class="hljs-title">lval_builtin</span><span class="hljs-params">(lbuiltin func)</span> </span>{
  lval* v = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(lval));
  v-&gt;type = LVAL_FUN;
  v-&gt;builtin = func;
  <span class="hljs-keyword">return</span> v;
}

<span class="hljs-function">lenv* <span class="hljs-title">lenv_new</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;

<span class="hljs-function">lval* <span class="hljs-title">lval_lambda</span><span class="hljs-params">(lval* formals, lval* body)</span> </span>{
  lval* v = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(lval));
  v-&gt;type = LVAL_FUN;  
  v-&gt;builtin = <span class="hljs-literal">NULL</span>;  
  v-&gt;env = lenv_new();  
  v-&gt;formals = formals;
  v-&gt;body = body;
  <span class="hljs-keyword">return</span> v;  
}

<span class="hljs-function">lval* <span class="hljs-title">lval_sexpr</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
  lval* v = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(lval));
  v-&gt;type = LVAL_SEXPR;
  v-&gt;count = <span class="hljs-number">0</span>;
  v-&gt;cell = <span class="hljs-literal">NULL</span>;
  <span class="hljs-keyword">return</span> v;
}

<span class="hljs-function">lval* <span class="hljs-title">lval_qexpr</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
  lval* v = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(lval));
  v-&gt;type = LVAL_QEXPR;
  v-&gt;count = <span class="hljs-number">0</span>;
  v-&gt;cell = <span class="hljs-literal">NULL</span>;
  <span class="hljs-keyword">return</span> v;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lenv_del</span><span class="hljs-params">(lenv* e)</span></span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lval_del</span><span class="hljs-params">(lval* v)</span> </span>{

  <span class="hljs-keyword">switch</span> (v-&gt;type) {
    <span class="hljs-keyword">case</span> LVAL_NUM: <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> LVAL_FUN: 
      <span class="hljs-keyword">if</span> (!v-&gt;builtin) {
        lenv_del(v-&gt;env);
        lval_del(v-&gt;formals);
        lval_del(v-&gt;body);
      }
    <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> LVAL_ERR: <span class="hljs-built_in">free</span>(v-&gt;err); <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> LVAL_SYM: <span class="hljs-built_in">free</span>(v-&gt;sym); <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> LVAL_QEXPR:
    <span class="hljs-keyword">case</span> LVAL_SEXPR:
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v-&gt;count; i++) {
        lval_del(v-&gt;cell[i]);
      }
      <span class="hljs-built_in">free</span>(v-&gt;cell);
    <span class="hljs-keyword">break</span>;
  }

  <span class="hljs-built_in">free</span>(v);
}

<span class="hljs-function">lenv* <span class="hljs-title">lenv_copy</span><span class="hljs-params">(lenv* e)</span></span>;

<span class="hljs-function">lval* <span class="hljs-title">lval_copy</span><span class="hljs-params">(lval* v)</span> </span>{
  lval* x = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(lval));
  x-&gt;type = v-&gt;type;
  <span class="hljs-keyword">switch</span> (v-&gt;type) {
    <span class="hljs-keyword">case</span> LVAL_FUN:
      <span class="hljs-keyword">if</span> (v-&gt;builtin) {
        x-&gt;builtin = v-&gt;builtin;
      } <span class="hljs-keyword">else</span> {
        x-&gt;builtin = <span class="hljs-literal">NULL</span>;
        x-&gt;env = lenv_copy(v-&gt;env);
        x-&gt;formals = lval_copy(v-&gt;formals);
        x-&gt;body = lval_copy(v-&gt;body);
      }
    <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> LVAL_NUM: x-&gt;num = v-&gt;num; <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> LVAL_ERR: x-&gt;err = <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">strlen</span>(v-&gt;err) + <span class="hljs-number">1</span>);
      <span class="hljs-built_in">strcpy</span>(x-&gt;err, v-&gt;err);
    <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> LVAL_SYM: x-&gt;sym = <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">strlen</span>(v-&gt;sym) + <span class="hljs-number">1</span>);
      <span class="hljs-built_in">strcpy</span>(x-&gt;sym, v-&gt;sym);
    <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> LVAL_SEXPR:
    <span class="hljs-keyword">case</span> LVAL_QEXPR:
      x-&gt;count = v-&gt;count;
      x-&gt;cell = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(lval*) * x-&gt;count);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; x-&gt;count; i++) {
        x-&gt;cell[i] = lval_copy(v-&gt;cell[i]);
      }
    <span class="hljs-keyword">break</span>;
  }
  <span class="hljs-keyword">return</span> x;
}

<span class="hljs-function">lval* <span class="hljs-title">lval_add</span><span class="hljs-params">(lval* v, lval* x)</span> </span>{
  v-&gt;count++;
  v-&gt;cell = <span class="hljs-built_in">realloc</span>(v-&gt;cell, <span class="hljs-keyword">sizeof</span>(lval*) * v-&gt;count);
  v-&gt;cell[v-&gt;count<span class="hljs-number">-1</span>] = x;
  <span class="hljs-keyword">return</span> v;
}

<span class="hljs-function">lval* <span class="hljs-title">lval_join</span><span class="hljs-params">(lval* x, lval* y)</span> </span>{  
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; y-&gt;count; i++) {
    x = lval_add(x, y-&gt;cell[i]);
  }
  <span class="hljs-built_in">free</span>(y-&gt;cell);
  <span class="hljs-built_in">free</span>(y);  
  <span class="hljs-keyword">return</span> x;
}

<span class="hljs-function">lval* <span class="hljs-title">lval_pop</span><span class="hljs-params">(lval* v, <span class="hljs-keyword">int</span> i)</span> </span>{
  lval* x = v-&gt;cell[i];  
  memmove(&amp;v-&gt;cell[i],
    &amp;v-&gt;cell[i+<span class="hljs-number">1</span>], <span class="hljs-keyword">sizeof</span>(lval*) * (v-&gt;count-i<span class="hljs-number">-1</span>));  
  v-&gt;count--;  
  v-&gt;cell = <span class="hljs-built_in">realloc</span>(v-&gt;cell, <span class="hljs-keyword">sizeof</span>(lval*) * v-&gt;count);
  <span class="hljs-keyword">return</span> x;
}

<span class="hljs-function">lval* <span class="hljs-title">lval_take</span><span class="hljs-params">(lval* v, <span class="hljs-keyword">int</span> i)</span> </span>{
  lval* x = lval_pop(v, i);
  lval_del(v);
  <span class="hljs-keyword">return</span> x;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lval_print</span><span class="hljs-params">(lval* v)</span></span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lval_print_expr</span><span class="hljs-params">(lval* v, <span class="hljs-keyword">char</span> open, <span class="hljs-keyword">char</span> close)</span> </span>{
  <span class="hljs-built_in">putchar</span>(open);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v-&gt;count; i++) {
    lval_print(v-&gt;cell[i]);    
    <span class="hljs-keyword">if</span> (i != (v-&gt;count<span class="hljs-number">-1</span>)) {
      <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&apos; &apos;</span>);
    }
  }
  <span class="hljs-built_in">putchar</span>(close);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lval_print</span><span class="hljs-params">(lval* v)</span> </span>{
  <span class="hljs-keyword">switch</span> (v-&gt;type) {
    <span class="hljs-keyword">case</span> LVAL_FUN:
      <span class="hljs-keyword">if</span> (v-&gt;builtin) {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&lt;builtin&gt;&quot;</span>);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(\\ &quot;</span>);
        lval_print(v-&gt;formals);
        <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&apos; &apos;</span>);
        lval_print(v-&gt;body);
        <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&apos;)&apos;</span>);
      }
    <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> LVAL_NUM:   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%li&quot;</span>, v-&gt;num); <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> LVAL_ERR:   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error: %s&quot;</span>, v-&gt;err); <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> LVAL_SYM:   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, v-&gt;sym); <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> LVAL_SEXPR: lval_print_expr(v, <span class="hljs-string">&apos;(&apos;</span>, <span class="hljs-string">&apos;)&apos;</span>); <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> LVAL_QEXPR: lval_print_expr(v, <span class="hljs-string">&apos;{&apos;</span>, <span class="hljs-string">&apos;}&apos;</span>); <span class="hljs-keyword">break</span>;
  }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lval_println</span><span class="hljs-params">(lval* v)</span> </span>{ lval_print(v); <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&apos;\n&apos;</span>); }

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lval_eq</span><span class="hljs-params">(lval* x, lval* y)</span> </span>{

  <span class="hljs-comment">/* Different Types are always unequal */</span>
  <span class="hljs-keyword">if</span> (x-&gt;type != y-&gt;type) { <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; }

  <span class="hljs-comment">/* Compare Based upon type */</span>
  <span class="hljs-keyword">switch</span> (x-&gt;type) {
    <span class="hljs-comment">/* Compare Number Value */</span>
    <span class="hljs-keyword">case</span> LVAL_NUM: <span class="hljs-keyword">return</span> (x-&gt;num == y-&gt;num);

    <span class="hljs-comment">/* Compare String Values */</span>
    <span class="hljs-keyword">case</span> LVAL_ERR: <span class="hljs-keyword">return</span> (<span class="hljs-built_in">strcmp</span>(x-&gt;err, y-&gt;err) == <span class="hljs-number">0</span>);
    <span class="hljs-keyword">case</span> LVAL_SYM: <span class="hljs-keyword">return</span> (<span class="hljs-built_in">strcmp</span>(x-&gt;sym, y-&gt;sym) == <span class="hljs-number">0</span>);

    <span class="hljs-comment">/* If Builtin compare functions, otherwise compare formals and body */</span>
    <span class="hljs-keyword">case</span> LVAL_FUN:
      <span class="hljs-keyword">if</span> (x-&gt;builtin || y-&gt;builtin) {
        <span class="hljs-keyword">return</span> x-&gt;builtin == y-&gt;builtin;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> lval_eq(x-&gt;formals, y-&gt;formals) &amp;&amp; lval_eq(x-&gt;body, y-&gt;body);
      }

    <span class="hljs-comment">/* If list compare every individual element */</span>
    <span class="hljs-keyword">case</span> LVAL_QEXPR:
    <span class="hljs-keyword">case</span> LVAL_SEXPR:
      <span class="hljs-keyword">if</span> (x-&gt;count != y-&gt;count) { <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; }
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; x-&gt;count; i++) {
        <span class="hljs-comment">/* If any element not equal then whole list not equal */</span>
        <span class="hljs-keyword">if</span> (!lval_eq(x-&gt;cell[i], y-&gt;cell[i])) { <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; }
      }
      <span class="hljs-comment">/* Otherwise lists must be equal */</span>
      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    <span class="hljs-keyword">break</span>;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">ltype_name</span><span class="hljs-params">(<span class="hljs-keyword">int</span> t)</span> </span>{
  <span class="hljs-keyword">switch</span>(t) {
    <span class="hljs-keyword">case</span> LVAL_FUN: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Function&quot;</span>;
    <span class="hljs-keyword">case</span> LVAL_NUM: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Number&quot;</span>;
    <span class="hljs-keyword">case</span> LVAL_ERR: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Error&quot;</span>;
    <span class="hljs-keyword">case</span> LVAL_SYM: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Symbol&quot;</span>;
    <span class="hljs-keyword">case</span> LVAL_SEXPR: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;S-Expression&quot;</span>;
    <span class="hljs-keyword">case</span> LVAL_QEXPR: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Q-Expression&quot;</span>;
    <span class="hljs-keyword">default</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Unknown&quot;</span>;
  }
}

<span class="hljs-comment">/* Lisp Environment */</span>

<span class="hljs-keyword">struct</span> lenv {
  lenv* par;
  <span class="hljs-keyword">int</span> count;
  <span class="hljs-keyword">char</span>** syms;
  lval** vals;
};

<span class="hljs-function">lenv* <span class="hljs-title">lenv_new</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
  lenv* e = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(lenv));
  e-&gt;par = <span class="hljs-literal">NULL</span>;
  e-&gt;count = <span class="hljs-number">0</span>;
  e-&gt;syms = <span class="hljs-literal">NULL</span>;
  e-&gt;vals = <span class="hljs-literal">NULL</span>;
  <span class="hljs-keyword">return</span> e;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lenv_del</span><span class="hljs-params">(lenv* e)</span> </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; e-&gt;count; i++) {
    <span class="hljs-built_in">free</span>(e-&gt;syms[i]);
    lval_del(e-&gt;vals[i]);
  }  
  <span class="hljs-built_in">free</span>(e-&gt;syms);
  <span class="hljs-built_in">free</span>(e-&gt;vals);
  <span class="hljs-built_in">free</span>(e);
}

<span class="hljs-function">lenv* <span class="hljs-title">lenv_copy</span><span class="hljs-params">(lenv* e)</span> </span>{
  lenv* n = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(lenv));
  n-&gt;par = e-&gt;par;
  n-&gt;count = e-&gt;count;
  n-&gt;syms = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>*) * n-&gt;count);
  n-&gt;vals = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(lval*) * n-&gt;count);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; e-&gt;count; i++) {
    n-&gt;syms[i] = <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">strlen</span>(e-&gt;syms[i]) + <span class="hljs-number">1</span>);
    <span class="hljs-built_in">strcpy</span>(n-&gt;syms[i], e-&gt;syms[i]);
    n-&gt;vals[i] = lval_copy(e-&gt;vals[i]);
  }
  <span class="hljs-keyword">return</span> n;
}

<span class="hljs-function">lval* <span class="hljs-title">lenv_get</span><span class="hljs-params">(lenv* e, lval* k)</span> </span>{

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; e-&gt;count; i++) {
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(e-&gt;syms[i], k-&gt;sym) == <span class="hljs-number">0</span>) { <span class="hljs-keyword">return</span> lval_copy(e-&gt;vals[i]); }
  }

  <span class="hljs-keyword">if</span> (e-&gt;par) {
    <span class="hljs-keyword">return</span> lenv_get(e-&gt;par, k);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> lval_err(<span class="hljs-string">&quot;Unbound Symbol &apos;%s&apos;&quot;</span>, k-&gt;sym);
  }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lenv_put</span><span class="hljs-params">(lenv* e, lval* k, lval* v)</span> </span>{

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; e-&gt;count; i++) {
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(e-&gt;syms[i], k-&gt;sym) == <span class="hljs-number">0</span>) {
      lval_del(e-&gt;vals[i]);
      e-&gt;vals[i] = lval_copy(v);
      <span class="hljs-keyword">return</span>;
    }
  }

  e-&gt;count++;
  e-&gt;vals = <span class="hljs-built_in">realloc</span>(e-&gt;vals, <span class="hljs-keyword">sizeof</span>(lval*) * e-&gt;count);
  e-&gt;syms = <span class="hljs-built_in">realloc</span>(e-&gt;syms, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>*) * e-&gt;count);  
  e-&gt;vals[e-&gt;count<span class="hljs-number">-1</span>] = lval_copy(v);
  e-&gt;syms[e-&gt;count<span class="hljs-number">-1</span>] = <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">strlen</span>(k-&gt;sym)+<span class="hljs-number">1</span>);
  <span class="hljs-built_in">strcpy</span>(e-&gt;syms[e-&gt;count<span class="hljs-number">-1</span>], k-&gt;sym);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lenv_def</span><span class="hljs-params">(lenv* e, lval* k, lval* v)</span> </span>{
  <span class="hljs-keyword">while</span> (e-&gt;par) { e = e-&gt;par; }
  lenv_put(e, k, v);
}

<span class="hljs-comment">/* Builtins */</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LASSERT(args, cond, fmt, ...) \
  <span class="hljs-meta-keyword">if</span> (!(cond)) { lval* err = lval_err(fmt, ##__VA_ARGS__); lval_del(args); return err; }</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LASSERT_TYPE(func, args, index, expect) \
  LASSERT(args, args-&gt;cell[index]-&gt;type == expect, \
    <span class="hljs-string">&quot;Function &apos;%s&apos; passed incorrect type for argument %i. Got %s, Expected %s.&quot;</span>, \
    func, index, ltype_name(args-&gt;cell[index]-&gt;type), ltype_name(expect))</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LASSERT_NUM(func, args, num) \
  LASSERT(args, args-&gt;count == num, \
    <span class="hljs-string">&quot;Function &apos;%s&apos; passed incorrect number of arguments. Got %i, Expected %i.&quot;</span>, \
    func, args-&gt;count, num)</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LASSERT_NOT_EMPTY(func, args, index) \
  LASSERT(args, args-&gt;cell[index]-&gt;count != 0, \
    <span class="hljs-string">&quot;Function &apos;%s&apos; passed {} for argument %i.&quot;</span>, func, index);</span>

<span class="hljs-function">lval* <span class="hljs-title">lval_eval</span><span class="hljs-params">(lenv* e, lval* v)</span></span>;

<span class="hljs-function">lval* <span class="hljs-title">builtin_lambda</span><span class="hljs-params">(lenv* e, lval* a)</span> </span>{
  LASSERT_NUM(<span class="hljs-string">&quot;\\&quot;</span>, a, <span class="hljs-number">2</span>);
  LASSERT_TYPE(<span class="hljs-string">&quot;\\&quot;</span>, a, <span class="hljs-number">0</span>, LVAL_QEXPR);
  LASSERT_TYPE(<span class="hljs-string">&quot;\\&quot;</span>, a, <span class="hljs-number">1</span>, LVAL_QEXPR);

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a-&gt;cell[<span class="hljs-number">0</span>]-&gt;count; i++) {
    LASSERT(a, (a-&gt;cell[<span class="hljs-number">0</span>]-&gt;cell[i]-&gt;type == LVAL_SYM),
      <span class="hljs-string">&quot;Cannot define non-symbol. Got %s, Expected %s.&quot;</span>,
      ltype_name(a-&gt;cell[<span class="hljs-number">0</span>]-&gt;cell[i]-&gt;type), ltype_name(LVAL_SYM));
  }

  lval* formals = lval_pop(a, <span class="hljs-number">0</span>);
  lval* body = lval_pop(a, <span class="hljs-number">0</span>);
  lval_del(a);

  <span class="hljs-keyword">return</span> lval_lambda(formals, body);
}

<span class="hljs-function">lval* <span class="hljs-title">builtin_list</span><span class="hljs-params">(lenv* e, lval* a)</span> </span>{
  a-&gt;type = LVAL_QEXPR;
  <span class="hljs-keyword">return</span> a;
}

<span class="hljs-function">lval* <span class="hljs-title">builtin_head</span><span class="hljs-params">(lenv* e, lval* a)</span> </span>{
  LASSERT_NUM(<span class="hljs-string">&quot;head&quot;</span>, a, <span class="hljs-number">1</span>);
  LASSERT_TYPE(<span class="hljs-string">&quot;head&quot;</span>, a, <span class="hljs-number">0</span>, LVAL_QEXPR);
  LASSERT_NOT_EMPTY(<span class="hljs-string">&quot;head&quot;</span>, a, <span class="hljs-number">0</span>);

  lval* v = lval_take(a, <span class="hljs-number">0</span>);  
  <span class="hljs-keyword">while</span> (v-&gt;count &gt; <span class="hljs-number">1</span>) { lval_del(lval_pop(v, <span class="hljs-number">1</span>)); }
  <span class="hljs-keyword">return</span> v;
}

<span class="hljs-function">lval* <span class="hljs-title">builtin_tail</span><span class="hljs-params">(lenv* e, lval* a)</span> </span>{
  LASSERT_NUM(<span class="hljs-string">&quot;tail&quot;</span>, a, <span class="hljs-number">1</span>);
  LASSERT_TYPE(<span class="hljs-string">&quot;tail&quot;</span>, a, <span class="hljs-number">0</span>, LVAL_QEXPR);
  LASSERT_NOT_EMPTY(<span class="hljs-string">&quot;tail&quot;</span>, a, <span class="hljs-number">0</span>);

  lval* v = lval_take(a, <span class="hljs-number">0</span>);  
  lval_del(lval_pop(v, <span class="hljs-number">0</span>));
  <span class="hljs-keyword">return</span> v;
}

<span class="hljs-function">lval* <span class="hljs-title">builtin_eval</span><span class="hljs-params">(lenv* e, lval* a)</span> </span>{
  LASSERT_NUM(<span class="hljs-string">&quot;eval&quot;</span>, a, <span class="hljs-number">1</span>);
  LASSERT_TYPE(<span class="hljs-string">&quot;eval&quot;</span>, a, <span class="hljs-number">0</span>, LVAL_QEXPR);

  lval* x = lval_take(a, <span class="hljs-number">0</span>);
  x-&gt;type = LVAL_SEXPR;
  <span class="hljs-keyword">return</span> lval_eval(e, x);
}

<span class="hljs-function">lval* <span class="hljs-title">builtin_join</span><span class="hljs-params">(lenv* e, lval* a)</span> </span>{

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a-&gt;count; i++) {
    LASSERT_TYPE(<span class="hljs-string">&quot;join&quot;</span>, a, i, LVAL_QEXPR);
  }

  lval* x = lval_pop(a, <span class="hljs-number">0</span>);

  <span class="hljs-keyword">while</span> (a-&gt;count) {
    lval* y = lval_pop(a, <span class="hljs-number">0</span>);
    x = lval_join(x, y);
  }

  lval_del(a);
  <span class="hljs-keyword">return</span> x;
}

<span class="hljs-function">lval* <span class="hljs-title">builtin_op</span><span class="hljs-params">(lenv* e, lval* a, <span class="hljs-keyword">char</span>* op)</span> </span>{

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a-&gt;count; i++) {
    LASSERT_TYPE(op, a, i, LVAL_NUM);
  }

  lval* x = lval_pop(a, <span class="hljs-number">0</span>);

  <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">strcmp</span>(op, <span class="hljs-string">&quot;-&quot;</span>) == <span class="hljs-number">0</span>) &amp;&amp; a-&gt;count == <span class="hljs-number">0</span>) { x-&gt;num = -x-&gt;num; }

  <span class="hljs-keyword">while</span> (a-&gt;count &gt; <span class="hljs-number">0</span>) {  
    lval* y = lval_pop(a, <span class="hljs-number">0</span>);

    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(op, <span class="hljs-string">&quot;+&quot;</span>) == <span class="hljs-number">0</span>) { x-&gt;num += y-&gt;num; }
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(op, <span class="hljs-string">&quot;-&quot;</span>) == <span class="hljs-number">0</span>) { x-&gt;num -= y-&gt;num; }
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(op, <span class="hljs-string">&quot;*&quot;</span>) == <span class="hljs-number">0</span>) { x-&gt;num *= y-&gt;num; }
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(op, <span class="hljs-string">&quot;/&quot;</span>) == <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">if</span> (y-&gt;num == <span class="hljs-number">0</span>) {
        lval_del(x); lval_del(y);
        x = lval_err(<span class="hljs-string">&quot;Division By Zero.&quot;</span>);
        <span class="hljs-keyword">break</span>;
      }
      x-&gt;num /= y-&gt;num;
    }

    lval_del(y);
  }

  lval_del(a);
  <span class="hljs-keyword">return</span> x;
}

<span class="hljs-function">lval* <span class="hljs-title">builtin_add</span><span class="hljs-params">(lenv* e, lval* a)</span> </span>{ <span class="hljs-keyword">return</span> builtin_op(e, a, <span class="hljs-string">&quot;+&quot;</span>); }
<span class="hljs-function">lval* <span class="hljs-title">builtin_sub</span><span class="hljs-params">(lenv* e, lval* a)</span> </span>{ <span class="hljs-keyword">return</span> builtin_op(e, a, <span class="hljs-string">&quot;-&quot;</span>); }
<span class="hljs-function">lval* <span class="hljs-title">builtin_mul</span><span class="hljs-params">(lenv* e, lval* a)</span> </span>{ <span class="hljs-keyword">return</span> builtin_op(e, a, <span class="hljs-string">&quot;*&quot;</span>); }
<span class="hljs-function">lval* <span class="hljs-title">builtin_div</span><span class="hljs-params">(lenv* e, lval* a)</span> </span>{ <span class="hljs-keyword">return</span> builtin_op(e, a, <span class="hljs-string">&quot;/&quot;</span>); }

<span class="hljs-function">lval* <span class="hljs-title">builtin_var</span><span class="hljs-params">(lenv* e, lval* a, <span class="hljs-keyword">char</span>* func)</span> </span>{
  LASSERT_TYPE(func, a, <span class="hljs-number">0</span>, LVAL_QEXPR);

  lval* syms = a-&gt;cell[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; syms-&gt;count; i++) {
    LASSERT(a, (syms-&gt;cell[i]-&gt;type == LVAL_SYM),
      <span class="hljs-string">&quot;Function &apos;%s&apos; cannot define non-symbol. &quot;</span>
      <span class="hljs-string">&quot;Got %s, Expected %s.&quot;</span>,
      func, ltype_name(syms-&gt;cell[i]-&gt;type), ltype_name(LVAL_SYM));
  }

  LASSERT(a, (syms-&gt;count == a-&gt;count<span class="hljs-number">-1</span>),
    <span class="hljs-string">&quot;Function &apos;%s&apos; passed too many arguments for symbols. &quot;</span>
    <span class="hljs-string">&quot;Got %i, Expected %i.&quot;</span>,
    func, syms-&gt;count, a-&gt;count<span class="hljs-number">-1</span>);

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; syms-&gt;count; i++) {
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(func, <span class="hljs-string">&quot;def&quot;</span>) == <span class="hljs-number">0</span>) { lenv_def(e, syms-&gt;cell[i], a-&gt;cell[i+<span class="hljs-number">1</span>]); }
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(func, <span class="hljs-string">&quot;=&quot;</span>)   == <span class="hljs-number">0</span>) { lenv_put(e, syms-&gt;cell[i], a-&gt;cell[i+<span class="hljs-number">1</span>]); } 
  }

  lval_del(a);
  <span class="hljs-keyword">return</span> lval_sexpr();
}

<span class="hljs-function">lval* <span class="hljs-title">builtin_def</span><span class="hljs-params">(lenv* e, lval* a)</span> </span>{ <span class="hljs-keyword">return</span> builtin_var(e, a, <span class="hljs-string">&quot;def&quot;</span>); }
<span class="hljs-function">lval* <span class="hljs-title">builtin_put</span><span class="hljs-params">(lenv* e, lval* a)</span> </span>{ <span class="hljs-keyword">return</span> builtin_var(e, a, <span class="hljs-string">&quot;=&quot;</span>); }

<span class="hljs-function">lval* <span class="hljs-title">builtin_ord</span><span class="hljs-params">(lenv* e, lval* a, <span class="hljs-keyword">char</span>* op)</span> </span>{
  LASSERT_NUM(op, a, <span class="hljs-number">2</span>);
  LASSERT_TYPE(op, a, <span class="hljs-number">0</span>, LVAL_NUM);
  LASSERT_TYPE(op, a, <span class="hljs-number">1</span>, LVAL_NUM);

  <span class="hljs-keyword">int</span> r;
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(op, <span class="hljs-string">&quot;&gt;&quot;</span>)  == <span class="hljs-number">0</span>) {
    r = (a-&gt;cell[<span class="hljs-number">0</span>]-&gt;num &gt;  a-&gt;cell[<span class="hljs-number">1</span>]-&gt;num);
  }
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(op, <span class="hljs-string">&quot;&lt;&quot;</span>)  == <span class="hljs-number">0</span>) {
    r = (a-&gt;cell[<span class="hljs-number">0</span>]-&gt;num &lt;  a-&gt;cell[<span class="hljs-number">1</span>]-&gt;num);
  }
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(op, <span class="hljs-string">&quot;&gt;=&quot;</span>) == <span class="hljs-number">0</span>) {
    r = (a-&gt;cell[<span class="hljs-number">0</span>]-&gt;num &gt;= a-&gt;cell[<span class="hljs-number">1</span>]-&gt;num);
  }
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(op, <span class="hljs-string">&quot;&lt;=&quot;</span>) == <span class="hljs-number">0</span>) {
    r = (a-&gt;cell[<span class="hljs-number">0</span>]-&gt;num &lt;= a-&gt;cell[<span class="hljs-number">1</span>]-&gt;num);
  }
  lval_del(a);
  <span class="hljs-keyword">return</span> lval_num(r);
}

<span class="hljs-function">lval* <span class="hljs-title">builtin_gt</span><span class="hljs-params">(lenv* e, lval* a)</span> </span>{
  <span class="hljs-keyword">return</span> builtin_ord(e, a, <span class="hljs-string">&quot;&gt;&quot;</span>);
}

<span class="hljs-function">lval* <span class="hljs-title">builtin_lt</span><span class="hljs-params">(lenv* e, lval* a)</span> </span>{
  <span class="hljs-keyword">return</span> builtin_ord(e, a, <span class="hljs-string">&quot;&lt;&quot;</span>);
}

<span class="hljs-function">lval* <span class="hljs-title">builtin_ge</span><span class="hljs-params">(lenv* e, lval* a)</span> </span>{
  <span class="hljs-keyword">return</span> builtin_ord(e, a, <span class="hljs-string">&quot;&gt;=&quot;</span>);
}

<span class="hljs-function">lval* <span class="hljs-title">builtin_le</span><span class="hljs-params">(lenv* e, lval* a)</span> </span>{
  <span class="hljs-keyword">return</span> builtin_ord(e, a, <span class="hljs-string">&quot;&lt;=&quot;</span>);
}

<span class="hljs-function">lval* <span class="hljs-title">builtin_cmp</span><span class="hljs-params">(lenv* e, lval* a, <span class="hljs-keyword">char</span>* op)</span> </span>{
  LASSERT_NUM(op, a, <span class="hljs-number">2</span>);
  <span class="hljs-keyword">int</span> r;
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(op, <span class="hljs-string">&quot;==&quot;</span>) == <span class="hljs-number">0</span>) {
    r =  lval_eq(a-&gt;cell[<span class="hljs-number">0</span>], a-&gt;cell[<span class="hljs-number">1</span>]);
  }
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(op, <span class="hljs-string">&quot;!=&quot;</span>) == <span class="hljs-number">0</span>) {
    r = !lval_eq(a-&gt;cell[<span class="hljs-number">0</span>], a-&gt;cell[<span class="hljs-number">1</span>]);
  }
  lval_del(a);
  <span class="hljs-keyword">return</span> lval_num(r);
}

<span class="hljs-function">lval* <span class="hljs-title">builtin_eq</span><span class="hljs-params">(lenv* e, lval* a)</span> </span>{
  <span class="hljs-keyword">return</span> builtin_cmp(e, a, <span class="hljs-string">&quot;==&quot;</span>);
}

<span class="hljs-function">lval* <span class="hljs-title">builtin_ne</span><span class="hljs-params">(lenv* e, lval* a)</span> </span>{
  <span class="hljs-keyword">return</span> builtin_cmp(e, a, <span class="hljs-string">&quot;!=&quot;</span>);
}

<span class="hljs-function">lval* <span class="hljs-title">builtin_if</span><span class="hljs-params">(lenv* e, lval* a)</span> </span>{
  LASSERT_NUM(<span class="hljs-string">&quot;if&quot;</span>, a, <span class="hljs-number">3</span>);
  LASSERT_TYPE(<span class="hljs-string">&quot;if&quot;</span>, a, <span class="hljs-number">0</span>, LVAL_NUM);
  LASSERT_TYPE(<span class="hljs-string">&quot;if&quot;</span>, a, <span class="hljs-number">1</span>, LVAL_QEXPR);
  LASSERT_TYPE(<span class="hljs-string">&quot;if&quot;</span>, a, <span class="hljs-number">2</span>, LVAL_QEXPR);

  <span class="hljs-comment">/* Mark Both Expressions as evaluable */</span>
  lval* x;
  a-&gt;cell[<span class="hljs-number">1</span>]-&gt;type = LVAL_SEXPR;
  a-&gt;cell[<span class="hljs-number">2</span>]-&gt;type = LVAL_SEXPR;

  <span class="hljs-keyword">if</span> (a-&gt;cell[<span class="hljs-number">0</span>]-&gt;num) {
    <span class="hljs-comment">/* If condition is true evaluate first expression */</span>
    x = lval_eval(e, lval_pop(a, <span class="hljs-number">1</span>));
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">/* Otherwise evaluate second expression */</span>
    x = lval_eval(e, lval_pop(a, <span class="hljs-number">2</span>));
  }

  <span class="hljs-comment">/* Delete argument list and return */</span>
  lval_del(a);
  <span class="hljs-keyword">return</span> x;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lenv_add_builtin</span><span class="hljs-params">(lenv* e, <span class="hljs-keyword">char</span>* name, lbuiltin func)</span> </span>{
  lval* k = lval_sym(name);
  lval* v = lval_builtin(func);
  lenv_put(e, k, v);
  lval_del(k); lval_del(v);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lenv_add_builtins</span><span class="hljs-params">(lenv* e)</span> </span>{
  <span class="hljs-comment">/* Variable Functions */</span>
  lenv_add_builtin(e, <span class="hljs-string">&quot;\\&quot;</span>,  builtin_lambda); 
  lenv_add_builtin(e, <span class="hljs-string">&quot;def&quot;</span>, builtin_def);
  lenv_add_builtin(e, <span class="hljs-string">&quot;=&quot;</span>,   builtin_put);

  <span class="hljs-comment">/* List Functions */</span>
  lenv_add_builtin(e, <span class="hljs-string">&quot;list&quot;</span>, builtin_list);
  lenv_add_builtin(e, <span class="hljs-string">&quot;head&quot;</span>, builtin_head);
  lenv_add_builtin(e, <span class="hljs-string">&quot;tail&quot;</span>, builtin_tail);
  lenv_add_builtin(e, <span class="hljs-string">&quot;eval&quot;</span>, builtin_eval);
  lenv_add_builtin(e, <span class="hljs-string">&quot;join&quot;</span>, builtin_join);

  <span class="hljs-comment">/* Mathematical Functions */</span>
  lenv_add_builtin(e, <span class="hljs-string">&quot;+&quot;</span>, builtin_add);
  lenv_add_builtin(e, <span class="hljs-string">&quot;-&quot;</span>, builtin_sub);
  lenv_add_builtin(e, <span class="hljs-string">&quot;*&quot;</span>, builtin_mul);
  lenv_add_builtin(e, <span class="hljs-string">&quot;/&quot;</span>, builtin_div);

  <span class="hljs-comment">/* Comparison Functions */</span>
  lenv_add_builtin(e, <span class="hljs-string">&quot;if&quot;</span>,    builtin_if);
  lenv_add_builtin(e, <span class="hljs-string">&quot;==&quot;</span>,    builtin_eq);
  lenv_add_builtin(e, <span class="hljs-string">&quot;!=&quot;</span>,    builtin_ne);
  lenv_add_builtin(e, <span class="hljs-string">&quot;&gt;&quot;</span>,  builtin_gt);
  lenv_add_builtin(e, <span class="hljs-string">&quot;&lt;&quot;</span>,  builtin_lt);
  lenv_add_builtin(e, <span class="hljs-string">&quot;&gt;=&quot;</span>, builtin_ge);
  lenv_add_builtin(e, <span class="hljs-string">&quot;&lt;=&quot;</span>, builtin_le);
}

<span class="hljs-comment">/* Evaluation */</span>

<span class="hljs-function">lval* <span class="hljs-title">lval_call</span><span class="hljs-params">(lenv* e, lval* f, lval* a)</span> </span>{

  <span class="hljs-keyword">if</span> (f-&gt;builtin) { <span class="hljs-keyword">return</span> f-&gt;builtin(e, a); }

  <span class="hljs-keyword">int</span> given = a-&gt;count;
  <span class="hljs-keyword">int</span> total = f-&gt;formals-&gt;count;

  <span class="hljs-keyword">while</span> (a-&gt;count) {

    <span class="hljs-keyword">if</span> (f-&gt;formals-&gt;count == <span class="hljs-number">0</span>) {
      lval_del(a);
      <span class="hljs-keyword">return</span> lval_err(<span class="hljs-string">&quot;Function passed too many arguments. &quot;</span>
        <span class="hljs-string">&quot;Got %i, Expected %i.&quot;</span>, given, total); 
    }

    lval* sym = lval_pop(f-&gt;formals, <span class="hljs-number">0</span>);

    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(sym-&gt;sym, <span class="hljs-string">&quot;&amp;&quot;</span>) == <span class="hljs-number">0</span>) {

      <span class="hljs-keyword">if</span> (f-&gt;formals-&gt;count != <span class="hljs-number">1</span>) {
        lval_del(a);
        <span class="hljs-keyword">return</span> lval_err(<span class="hljs-string">&quot;Function format invalid. &quot;</span>
          <span class="hljs-string">&quot;Symbol &apos;&amp;&apos; not followed by single symbol.&quot;</span>);
      }

      lval* nsym = lval_pop(f-&gt;formals, <span class="hljs-number">0</span>);
      lenv_put(f-&gt;env, nsym, builtin_list(e, a));
      lval_del(sym); lval_del(nsym);
      <span class="hljs-keyword">break</span>;
    }

    lval* val = lval_pop(a, <span class="hljs-number">0</span>);    
    lenv_put(f-&gt;env, sym, val);    
    lval_del(sym); lval_del(val);
  }

  lval_del(a);

  <span class="hljs-keyword">if</span> (f-&gt;formals-&gt;count &gt; <span class="hljs-number">0</span> &amp;&amp;
    <span class="hljs-built_in">strcmp</span>(f-&gt;formals-&gt;cell[<span class="hljs-number">0</span>]-&gt;sym, <span class="hljs-string">&quot;&amp;&quot;</span>) == <span class="hljs-number">0</span>) {

    <span class="hljs-keyword">if</span> (f-&gt;formals-&gt;count != <span class="hljs-number">2</span>) {
      <span class="hljs-keyword">return</span> lval_err(<span class="hljs-string">&quot;Function format invalid. &quot;</span>
        <span class="hljs-string">&quot;Symbol &apos;&amp;&apos; not followed by single symbol.&quot;</span>);
    }

    lval_del(lval_pop(f-&gt;formals, <span class="hljs-number">0</span>));

    lval* sym = lval_pop(f-&gt;formals, <span class="hljs-number">0</span>);
    lval* val = lval_qexpr();    
    lenv_put(f-&gt;env, sym, val);
    lval_del(sym); lval_del(val);
  }

  <span class="hljs-keyword">if</span> (f-&gt;formals-&gt;count == <span class="hljs-number">0</span>) {  
    f-&gt;env-&gt;par = e;    
    <span class="hljs-keyword">return</span> builtin_eval(f-&gt;env, lval_add(lval_sexpr(), lval_copy(f-&gt;body)));
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> lval_copy(f);
  }

}

<span class="hljs-function">lval* <span class="hljs-title">lval_eval_sexpr</span><span class="hljs-params">(lenv* e, lval* v)</span> </span>{

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v-&gt;count; i++) { v-&gt;cell[i] = lval_eval(e, v-&gt;cell[i]); }
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v-&gt;count; i++) { <span class="hljs-keyword">if</span> (v-&gt;cell[i]-&gt;type == LVAL_ERR) { <span class="hljs-keyword">return</span> lval_take(v, i); } }

  <span class="hljs-keyword">if</span> (v-&gt;count == <span class="hljs-number">0</span>) { <span class="hljs-keyword">return</span> v; }  
  <span class="hljs-keyword">if</span> (v-&gt;count == <span class="hljs-number">1</span>) { <span class="hljs-keyword">return</span> lval_eval(e, lval_take(v, <span class="hljs-number">0</span>)); }

  lval* f = lval_pop(v, <span class="hljs-number">0</span>);
  <span class="hljs-keyword">if</span> (f-&gt;type != LVAL_FUN) {
    lval* err = lval_err(
      <span class="hljs-string">&quot;S-Expression starts with incorrect type. &quot;</span>
      <span class="hljs-string">&quot;Got %s, Expected %s.&quot;</span>,
      ltype_name(f-&gt;type), ltype_name(LVAL_FUN));
    lval_del(f); lval_del(v);
    <span class="hljs-keyword">return</span> err;
  }

  lval* result = lval_call(e, f, v);
  lval_del(f);
  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-function">lval* <span class="hljs-title">lval_eval</span><span class="hljs-params">(lenv* e, lval* v)</span> </span>{
  <span class="hljs-keyword">if</span> (v-&gt;type == LVAL_SYM) {
    lval* x = lenv_get(e, v);
    lval_del(v);
    <span class="hljs-keyword">return</span> x;
  }
  <span class="hljs-keyword">if</span> (v-&gt;type == LVAL_SEXPR) { <span class="hljs-keyword">return</span> lval_eval_sexpr(e, v); }
  <span class="hljs-keyword">return</span> v;
}

<span class="hljs-comment">/* Reading */</span>

<span class="hljs-function">lval* <span class="hljs-title">lval_read_num</span><span class="hljs-params">(mpc_ast_t* t)</span> </span>{
  errno = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">long</span> x = strtol(t-&gt;contents, <span class="hljs-literal">NULL</span>, <span class="hljs-number">10</span>);
  <span class="hljs-keyword">return</span> errno != ERANGE ? lval_num(x) : lval_err(<span class="hljs-string">&quot;Invalid Number.&quot;</span>);
}

<span class="hljs-function">lval* <span class="hljs-title">lval_read</span><span class="hljs-params">(mpc_ast_t* t)</span> </span>{

  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(t-&gt;tag, <span class="hljs-string">&quot;number&quot;</span>)) { <span class="hljs-keyword">return</span> lval_read_num(t); }
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(t-&gt;tag, <span class="hljs-string">&quot;symbol&quot;</span>)) { <span class="hljs-keyword">return</span> lval_sym(t-&gt;contents); }

  lval* x = <span class="hljs-literal">NULL</span>;
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(t-&gt;tag, <span class="hljs-string">&quot;&gt;&quot;</span>) == <span class="hljs-number">0</span>) { x = lval_sexpr(); } 
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(t-&gt;tag, <span class="hljs-string">&quot;sexpr&quot;</span>))  { x = lval_sexpr(); }
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(t-&gt;tag, <span class="hljs-string">&quot;qexpr&quot;</span>))  { x = lval_qexpr(); }

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; t-&gt;children_num; i++) {
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(t-&gt;children[i]-&gt;contents, <span class="hljs-string">&quot;(&quot;</span>) == <span class="hljs-number">0</span>) { <span class="hljs-keyword">continue</span>; }
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(t-&gt;children[i]-&gt;contents, <span class="hljs-string">&quot;)&quot;</span>) == <span class="hljs-number">0</span>) { <span class="hljs-keyword">continue</span>; }
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(t-&gt;children[i]-&gt;contents, <span class="hljs-string">&quot;}&quot;</span>) == <span class="hljs-number">0</span>) { <span class="hljs-keyword">continue</span>; }
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(t-&gt;children[i]-&gt;contents, <span class="hljs-string">&quot;{&quot;</span>) == <span class="hljs-number">0</span>) { <span class="hljs-keyword">continue</span>; }
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(t-&gt;children[i]-&gt;tag,  <span class="hljs-string">&quot;regex&quot;</span>) == <span class="hljs-number">0</span>) { <span class="hljs-keyword">continue</span>; }
    x = lval_add(x, lval_read(t-&gt;children[i]));
  }

  <span class="hljs-keyword">return</span> x;
}

<span class="hljs-comment">/* Main */</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span> </span>{

  <span class="hljs-keyword">mpc_parser_t</span>* Number = mpc_new(<span class="hljs-string">&quot;number&quot;</span>);
  <span class="hljs-keyword">mpc_parser_t</span>* Symbol = mpc_new(<span class="hljs-string">&quot;symbol&quot;</span>);
  <span class="hljs-keyword">mpc_parser_t</span>* Sexpr  = mpc_new(<span class="hljs-string">&quot;sexpr&quot;</span>);
  <span class="hljs-keyword">mpc_parser_t</span>* Qexpr  = mpc_new(<span class="hljs-string">&quot;qexpr&quot;</span>);
  <span class="hljs-keyword">mpc_parser_t</span>* Expr   = mpc_new(<span class="hljs-string">&quot;expr&quot;</span>);
  <span class="hljs-keyword">mpc_parser_t</span>* Lispy  = mpc_new(<span class="hljs-string">&quot;lispy&quot;</span>);

  mpca_lang(MPCA_LANG_DEFAULT,
    <span class="hljs-string">&quot;                                                     \
      number : /-?[0-9]+/ ;                               \
      symbol : /[a-zA-Z0-9_+\\-*\\/\\\\=&lt;&gt;!&amp;]+/ ;         \
      sexpr  : &apos;(&apos; &lt;expr&gt;* &apos;)&apos; ;                          \
      qexpr  : &apos;{&apos; &lt;expr&gt;* &apos;}&apos; ;                          \
      expr   : &lt;number&gt; | &lt;symbol&gt; | &lt;sexpr&gt; | &lt;qexpr&gt; ;  \
      lispy  : /^/ &lt;expr&gt;* /$/ ;                          \
    &quot;</span>,
    Number, Symbol, Sexpr, Qexpr, Expr, Lispy);

  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Lispy Version 0.0.0.0.9&quot;</span>);
  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Press Ctrl+c to Exit\n&quot;</span>);

  lenv* e = lenv_new();
  lenv_add_builtins(e);

  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {

    <span class="hljs-keyword">char</span>* input = readline(<span class="hljs-string">&quot;lispy&gt; &quot;</span>);
    add_history(input);

    <span class="hljs-keyword">mpc_result_t</span> r;
    <span class="hljs-keyword">if</span> (mpc_parse(<span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, input, Lispy, &amp;r)) {

      lval* x = lval_eval(e, lval_read(r.output));
      lval_println(x);
      lval_del(x);

      mpc_ast_delete(r.output);
    } <span class="hljs-keyword">else</span> {    
      mpc_err_print(r.error);
      mpc_err_delete(r.error);
    }

    <span class="hljs-built_in">free</span>(input);

  }

  lenv_del(e);

  mpc_cleanup(<span class="hljs-number">6</span>, Number, Symbol, Sexpr, Qexpr, Expr, Lispy);

  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
</details></p>
<script src="_gitbook_plugin_analytics.js"></script>
                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="12.Functions.html" class="navigation navigation-prev " aria-label="Previous page: 第十二章 • 函数">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="14.Strings.html" class="navigation navigation-next " aria-label="Next page: 第十四章 • 字符串">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"第十三章 • 条件分支","level":"1.14","depth":1,"next":{"title":"第十四章 • 字符串","level":"1.15","depth":1,"path":"14.Strings.md","ref":"14.Strings.md","articles":[]},"previous":{"title":"第十二章 • 函数","level":"1.13","depth":1,"path":"12.Functions.md","ref":"12.Functions.md","articles":[]},"dir":"ltr"},"config":{"plugins":["disqus","anchor-navigation-ex-toc","theme-gestalt","-theme-default","styles-sass-fix","analytics","collapse","adsense"],"styles":{"website":"website-1533951536666.css"},"pluginsConfig":{"disqus":{"useIdentifier":false,"shortName":"buildyourownlispcn"},"styles-sass-fix":{},"theme-gestalt":{"showLevel":false,"styles":{"website":"styles/website.css"},"logo":"./assets/logo.png","favicon":"./assets/logo.png","baseUrl":null,"excludeDefaultStyles":true,"doNotHideChildrenChapters":false},"analytics":{"google":"UA-48498357-5"},"search":{},"adsense":{"client":"ca-pub-6482217598104186","slot":"7152539784","format":"auto","element":".page-inner section","position":"bottom"},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"collapse":{},"anchor-navigation-ex-toc":{"associatedWithSummary":true,"float":{"level1Icon":"","level2Icon":"","level3Icon":"","showLevelIcon":false},"mode":"float","multipleH1":true,"pageTop":{"level1Icon":"","level2Icon":"","level3Icon":"","showLevelIcon":false},"printLog":false,"showLevel":true},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"github-edit":{"repo":"NoahDragon/BuildYourOwnLispCn","branch":"master"},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"学C语言写Lisp","language":"zh","gitbook":"*"},"file":{"path":"13.Conditionals.md","mtime":"2018-08-11T01:36:37.146Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2018-08-11T01:38:55.312Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/URI.js/1.16.1/URI.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-disqus/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-collapse/collapse.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-adsense/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

